---
import { type SchemaOf, createSchema } from 'astro-frontmatter-components';
import { type SchemaContext, z } from 'astro:content';
import { DefaultPos } from '@/schemas';
import business from '#/business.json';

export const schema = createSchema('Reviews', (_: SchemaContext) => ({
	id: z.string().optional(),
	pos: DefaultPos,
	title: z.string(),
	content: z.array(
		z.object({
			title: z.string(),
			desc: z.string(),
			date: z.coerce.date().optional(),
			url: z.string().optional(),
			location: z.string(),
			stars: z.number(),
			id: z.string().optional(),
		}),
	),
}));

export const seo = async (Astro: Astro, reviews: Props[]) => {
	return {
		aggregateRating: {
			'@type': 'AggregateRating',
			ratingValue: parseFloat(
				(
					reviews
						.flatMap((review) => review.content)
						.reduce((total, content) => total + content.stars, 0) /
					reviews.flatMap((review) => review.content).length
				).toFixed(1),
			),
			reviewCount: reviews.flatMap((review) => review.content).length,
			bestRating: 5,
			worstRating: 0,
			itemReviewed: {
				'@type': business['@type'],
				'@id': `${Astro.url.origin}#company`,
			},
		},
		review: await Promise.all(
			reviews.flatMap((review) =>
				review.content.map(async (content) => ({
					'@type': 'Review',
					author: {
						'@type': 'Person',
						name: content.title,
					},
					itemReviewed: {
						'@type': business['@type'],
						'@id': `${Astro.url.origin}#company`,
					},
					contentLocation: {
						'@type': 'Place',
						name: content.location,
					},
					reviewRating: {
						'@type': 'Rating',
						ratingValue: content.stars,
						bestRating: 5,
					},
					reviewBody: await markdown.parseInline(content.desc),
					...(content.date && { datePublished: content.date.toISOString() }),
					...(content.url && {
						associatedMedia: {
							'@type': 'MediaObject',
							associatedArticle: content.url,
						},
					}),
				})),
			),
		),
	};
};

export type Props = SchemaOf<typeof schema>;
const meta = Astro.props as Props;

import * as Layout from '@/components/Layout';
import Island from './Reviews';
import markdown from '@/build/markdown';

for (const [_, review] of meta.content.entries()) {
	review.desc = await markdown.parseInline(review.desc);
}
---

<Layout.Divider id={meta.id}>
	<Layout.Title title={meta.title} pos={meta.pos} />
	<div class="contain-paint">
		<Layout.Container variant="inner" class="select-none">
			<Island client:visible meta={meta.content} />
		</Layout.Container>
	</div>
</Layout.Divider>

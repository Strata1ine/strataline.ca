---
import { Icon } from "astro-icon/components";

const {
  text = [
    "Made with love",
    "No scrape of dust left",
    "Absolutely revelatory",
    "Expert opinions",
  ],
  speed = 0.45,
  ...slot
} = Astro.props;
---

<div class="py-inset border-accent border-y-1" {...slot}>
  <div class="contain-paint" data-text-carousel-wrapper>
    <div
      data-text-carousel
      data-speed={speed}
      class="flex h-18 transform-gpu touch-pan-y items-center gap-12 will-change-transform select-none md:h-20 md:gap-20 lg:gap-25 xl:h-25"
    >
      {
        text.map((text: string) => (
          <>
            <h4 class="flex-shrink-0 font-serif text-4xl">{text}</h4>
            <Icon
              name="ph:star-four-fill"
              class="text-gold h-auto w-8 flex-shrink-0"
              aria-hidden="true"
            />
          </>
        ))
      }
    </div>
  </div>
</div>

<script>
  // @ts-check

  document
    .querySelectorAll("[data-text-carousel-wrapper]")
    .forEach((wrapper) => {
      const carousel = wrapper.querySelector(
        "[data-text-carousel]",
      ) as HTMLElement;

      carousel.innerHTML += carousel.innerHTML;

      const speedAttr = parseFloat(
        carousel.getAttribute("data-speed") ?? "1.0",
      );

      const wantedSpeed = isNaN(speedAttr) ? 1.0 : speedAttr;

      let autoDirection = 1;
      let currentSpeed = wantedSpeed;
      let isDown = false;
      let startX = 0;
      let dragOffset = 0;
      let rawOffset = 0;
      let lastXDiff = 0;

      function updateTranslation() {
        const halfWidth = carousel.scrollWidth / 2;
        const visibleOffset = ((rawOffset % halfWidth) + halfWidth) % halfWidth;
        carousel.setAttribute(
          "style",
          `transform: translateX(-${visibleOffset}px)`,
        );
      }

      function animate() {
        const e = carousel.getBoundingClientRect();
        if (!isDown && !(e.bottom < 0 || e.top > window.innerHeight)) {
          rawOffset += autoDirection * currentSpeed;
          updateTranslation();
        }

        requestAnimationFrame(animate);
      }

      animate();

      wrapper.addEventListener("pointerdown", ((e: PointerEvent): void => {
        isDown = true;
        currentSpeed = 0;
        startX = e.pageX;
        dragOffset = rawOffset;
        wrapper.setPointerCapture(e.pointerId);
        e.preventDefault();
      }) as EventListener);

      wrapper.addEventListener("pointermove", ((e: PointerEvent): void => {
        if (!isDown) return;
        const xDiff = e.pageX - startX;
        lastXDiff = xDiff;
        rawOffset = dragOffset - xDiff;
        updateTranslation();
      }) as EventListener);

      wrapper.addEventListener("pointerup", ((e: PointerEvent): void => {
        isDown = false;
        currentSpeed = wantedSpeed;
        wrapper.releasePointerCapture(e.pointerId);
        autoDirection = lastXDiff > 0 ? -1 : 1;
      }) as EventListener);

      wrapper.addEventListener("pointercancel", ((e: PointerEvent): void => {
        isDown = false;
        currentSpeed = wantedSpeed;
        wrapper.releasePointerCapture(e.pointerId);
      }) as EventListener);
    });
</script>
